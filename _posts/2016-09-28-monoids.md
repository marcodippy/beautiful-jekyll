---
layout: post
published: false
title: Monoids
tags:
  - functional-programming
  - monoids
  - scala
date: '2016-09-28'
subtitle: >-
  _Monoid_... I love the way this word sounds, so this definitely must be the
  topic for my new blog post.
---
> _The path of the functional programmer is beset on all sides by the inequities of the selfish and the tyranny of Category Theory.
Blessed is he, who in the name of charity and good will, shepherds the weak through the valley of darkness,  for he is truly his brother's keeper and the finder of lost children.
And I will strike down upon thee with great vengeance and furious anger those who would attempt to poison and destroy my brothers by talking about_ **Morphisms**, **Arrows**, **Categories** _and other_ **confusing things with funny names**_._

A lot of FP concepts bear a scary name like _Functor_ or _Monad_ coming from category theory (subject I know ___nothing___ about), but despite their names, some of these concepts are fairly easy to grasp. One of the easiest is called **monoid**.

In few words, monoids are abstraction over things that can be _“aggregated/summed up”_ with an associative binary operation. That's all. 

More formally, a monoid is a **set of objects** plus a binary **operation** to combine those objects that must obey the following laws:

* *Closure Law*: the result of the _operation_ must be an element of the input set (if _(a, b) ∈ S_  and _operation(a, b) = x_ then _x ∈ S_).
* Associative Law: (a _op_ b) _op_ c == a _op_ (b _op_ c).
* Identity Element: the _operation_ must have an element (also called _zero_) that "does nothing": zero _op_ a == a and a _op_ zero == a (these are called, respectively, _left identity_ and _right identity_

To make it event more crystal clear, here are some examples:

| Set      | Operation | Identity Elem.     | Monoid? | Why?                                                                                                 |
|----------|:---------:|--------------------|---------|------------------------------------------------------------------------------------------------------|
| Integers | +         | 0                  | Yes     | a + b = c => c is always an Integer <br /> (1 + 2) + 3 = 1 + (2 + 3) <br /> a + 0 = a and 0 + a = a  |
| Integers | *         | 1                  | Yes     |                                                                                                      |
| Integers | /         |                    | No      | 5 / 2 = 2.5 => not an Integer                                                                        |
| Integers | max       | Integers.MIN_VALUE | Yes     |                                                                                                      |
| Strings  | concat    | ""                 | Yes     | I'm sure you can figure it out                                                                       |
| List     | concat    | empty list         | Yes     | same as above                                                                                        |
| Boolean  | AND       | true               | Yes     | try it yourself           


Ok, at this point you should have understood what a monoid is, but you're probably wondering why these laws are so important (if you're not, you should!).

### Why the closure law ???
Suppose that you want to calculate the sum of a list of integers List(1,2,3,4) and suppose that we start by summing 1 and 2 (remember that our operation is binary): 1+2 = 3 => List(3,3,4). Again: 3+3 = 6 => List(6,4). Again! 6+4 = 10. Great, we applied our "sum" monoid to the entire list and we got our result. If at one of these steps the operation returned a Float instead of an Integer, our monoid would no longer be suitable for the task (our monoid knows how to sum _Integers_).
So, the benefit of ensuring the closure law is that we can make our binary operation working on arbitrarily long sets of elements (list, sequences or even trees!).

### Why an associative operation ???
Do you really want to operate on a list (for example) and be forced to define the order of every operation? who cares if we start from the first or the last element of the list? And, more important, how can you parallelize your operation if it must follow a specific order?
Using associative operations facilitate parallel computation by letting us free to _divide and conquer_ our algorithms.

### Why an identity element ???
What should you return if your list is empty? what can you do with a binary operation and a list with a single element? 
 

## Ok ok, I got it, but now I wanna see some code
Ok let's write some monoids!

```scala
trait Monoid[A] {
  def append(a1: A, a2: A): A
  def zero: A
}

val stringMonoid = new Monoid[String] {
  def append(a1: String, a2: String) = a1 + a2
  val zero = ""
}

val intMonoid = new Monoid[Int] {
  def append(a1: Int, a2: Int) = a1 + a2
  val zero = 0
}

List("I", "love", "scala").fold(stringMonoid.zero)(stringMonoid.append) // "Ilovescala"
List(1, 2, 3).fold(intMonoid.zero)(intMonoid.append) // 6
```

(Beware that just creating a trait named `Monoid` doesn't mean that scala enforces the _"Monoid laws"_ for you, so remember to *test* that `append` is really associative and respects the closure law)

I guess you don't need further explaination to understand this basic example. 
As we know, monoids allow us to abstract over the types we're "reducing", so I'm legitimate to create a generic function like this that works for every type `A` for which a `Monoid[A]` is defined:

```scala
def sum[A] (l: List[A])(m: Monoid[A]) = l.fold(m.zero)(m.append)
```

Cool, now we can use our `sum` function for `List[String]` and `List[Int]`:

```scala
sum(List("I", "love", "scala"))(stringMonoid) // "Ilovescala"
sum(List(1,2,3))(intMonoid) // 6
```

There's a trick we can use to avoid passing everytime the monoid instance to the sum function, this trick is called `implicit parameter`:

```scala
implicit val stringMonoid = new Monoid[String] { ... }
implicit val intMonoid = new Monoid[Int] { ... }

def sum[A] (l: List[A])(implicit m: Monoid[A]) = l.fold(m.zero)(m.append)

sum(List("I", "love", "scala")) // "Ilovescala"
sum(List(1,2,3)) // 6
```

Nice, now our code looks cleaner... but you still have to discover the real power of monoids.

# Monoids compose!
Yes, you heard it right! If you have two monoids you can compose them and get a new monoid (this is called _product_).
Let's write a function to compose two monoids:

```scala
def composeMonoids[A, B](ma: Monoid[A], mb: Monoid[B]) = new Monoid[(A, B)] {
  def append(x: (A, B), y: (A, B)): (A, B) =
    (x, y) match {
      case ((a1, b1), (a2, b2)) => (ma.append(a1, a2), mb.append(b1, b2))
    }

  def zero: (A, B) = (ma.zero, mb.zero)
}
```

Wow, that was easy!
Now if we have to "sum" the list

```scala
val listOfTuples: List[(Int, String)] = List((1, "I"), (2, "love"), (3, "scala"))
```

we can reuse the monoids we already wrote for `Int` and `String`

```scala
implicit val newComposedMonoid: Monoid[(Int, String)] = composeMonoids(intMonoid, stringMonoid);

sum(listOfTuples) // (6, "Ilovescala")
```

Another super interesting monoid can be defined for merging `Map`s as long as the value type has a monoid:
```scala
def mapMergeMonoid[K, V](V: Monoid[V]): Monoid[Map[K, V]] = new Monoid[Map[K, V]] {
  def append(a: Map[K, V], b: Map[K, V]) =
    (a.keySet ++ b.keySet).foldLeft(zero) { (acc, k) =>
      acc.updated(k, V.append(a.getOrElse(k, V.zero),
        b.getOrElse(k, V.zero)))
    }

  def zero = Map[K, V]()
}

implicit val mapMonoid = mapMergeMonoid[String, Int](intMonoid);

val listMaps = List(
  Map("a" -> 1, "b" -> 2),
  Map("a" -> 1, "c" -> 3)
)

sum(listMaps) // Map(a -> 2, b -> 2, c -> 3)
```

This can be useful if we are building histograms for example; what if we want to build a "3D histogram" ?

```scala
implicit val mapOfMapsMonoid = mapMergeMonoid[String, Map[String, Int]](mapMonoid);

val listMapOfMaps = List(
  Map("a" -> Map("aa" -> 1), "b" -> Map("bb" -> 2)),
  Map("a" -> Map("aa" -> 1), "c" -> Map("cc" -> 3)),
  Map("a" -> Map("ab" -> 1))
)

sum(listMapOfMaps) 
/*
  Map(
    a -> Map(aa -> 2, ab -> 1), 
    b -> Map(bb -> 2), 
    c -> Map(cc -> 3)
  )
 */
```

So, we've seen that we can use monoids to abstract over the type we're "reducing"; we've build monoids for `Int`, `String` and `Map` and we've made our `sum` function working on `List`s of all of these types. But at this point you should feel some kind of itch, something can be improved, there something more we can abstract over... And you'd be right, there something more we can do: we should the `sum` function be limited to `List`s? `sum` internally uses `fold` to "iterate" over the elements, and just like monoids abstract over the "reduced" type, there's an abstraction over the type that is folded... try to guess the name! Yes, it's `Foldable`! Unfortunately this blog post is about monoids and I still have other things I want to show you, so if you're too greedy and you can't wait for finding out what a Foldable is, feel free to use our best friend **Google**.

---

Another good news is that we don't have to reinvent the wheel everytime we need a monoid, there are libraries that provide you all the infrastructure needed to work with this abstraction (and many others): the best known are [Cats](https://github.com/typelevel/cats) and [Scalaz](https://github.com/scalaz/scalaz). I'll use `scalaz` here to show some use cases for monoids.


Suppose that we're collecting all the events happening in our supercool platform and we have something like this:
```scala
case class Event(date: LocalDate, eventType: String, revenue: BigDecimal, cost: BigDecimal)

val events = List(
  Event(LocalDate.of(2016, 6, 25), "event_A", 10, 5),
  Event(LocalDate.of(2016, 9, 10), "event_A", 20, 6),
  Event(LocalDate.of(2016, 6, 25), "event_B", 30, 7)
)
```

Our first task is to calculate the total revenue over all our events; and since we've just discovered monoids and we're super excited about them, we write something like this:

```scala
def totalRevenue(revenues: Seq[BigDecimal]) = revenues.fold(Monoid[BigDecimal].zero)(_ |+| _)

totalRevenue(events.map(_.revenue)) // 60
```

As you can imagine, `scalaz` already defines some common monoids like Monoid[Int], Monoid[String] and the one we're using here `Monoid[BigDecimal]`, and provides us a convenient `|+|` operator for the `append` function.

Our boss now wants to know the total cost along with the revenue:
```scala
def totRevenueAndCost(revsAndCosts: Seq[(BigDecimal, BigDecimal)]) =
	revsAndCosts.fold(Monoid[(BigDecimal, BigDecimal)].zero)(_ |+| _)

totRevenueAndCost(events.map(e => (e.revenue, e.cost))) // (60, 18)
```

... and one day later he asks for the total number of events. 
At this point we want to improve our code a bit. We start by creating a class `Stats` that will contain the results and the relative monoid instance:

```scala
case class Stats(events: Long, revenue: BigDecimal, cost: BigDecimal)

implicit val statsMonoid = new Monoid[Stats] {
  override def zero: Stats = Stats(0, 0, 0)

  override def append(s1: Stats, s2: => Stats): Stats =
    Stats(
      s1.events |+| s2.events,
      s1.revenue |+| s2.revenue,
      s1.cost |+| s2.cost
    )
}
```

but as soon as we start writing
```scala
events.map(e => Stats(1, e.revenue, e.cost)).fold(Monoid[Stats].zero)(_ |+| _)
```
the _abstractions deamon_ inside us recognises a common pattern that we can factor out: we're always mapping over our `events` list to convert the event in something that has a monoid instance (`BigDecimal` initially, `Stats` this time). So, it's time to create our generic `foldMap` function once and for all:

```scala
//(this function already exists in `scalaz`)
def foldMap[A,B](as: List[A])(f: A => B)(implicit m: Monoid[B]): B =
  as.foldLeft(m.zero)((b, a) => m.append(b, f(a)))
```

Now we are ready to complete our task:
```scala
def eventToStat (e: Event) = Stats(1, e.revenue, e.cost)

foldMap(events)(eventToStat) // Stats(3, 60, 18)
```
(Scalaz already defines `foldMap` on `Foldable`, so we could have written `events.foldMap(eventToStat)`)

Great, now the logic for "iterating" over the list and the logic for computing the results are completely decoupled.


One last example of the powerfulness of monoids. As mentioned before, we can have a monoid instance for merging `Map`s as long as there's a monoid instance defined for the value type. This can be useful if we have to calculate our `Stats` by, for example, `eventType` or `date`:

```scala
def eventToStatsByEventType(e: Event) = Map(e.eventType -> eventToStats(e))
def eventToStatsByDate(e: Event) = Map(e.date -> eventToStats(e))

events.foldMap(eventToStatsByEventType)
/*
	Map(
	    event_A -> Stats(2,30,11),
    	event_B -> Stats(1,30,7)
    )
*/

events.foldMap(eventToStatsByDate)
/*
	Map(
	    2016-06-25 -> Stats(2,40,12),
    	2016-09-10 -> Stats(1,20,6)
    )
*/
```

You can also _"compose"_ these aggregation to create new aggregations:

```scala
def eventToStatsByTypeAndDate(e: Event) = Map(e.date -> eventToStatsByEventType(e))

events.foldMap(eventToStatsByTypeAndDate)
/*
	Map(
    	2016-06-25 -> Map(event_A -> Stats(1,10,5), event_B -> Stats(1,30,7)),
    	2016-09-10 -> Map(event_A -> Stats(1,20,6)) 
    )
*/
```

